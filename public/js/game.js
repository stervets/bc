// Generated by CoffeeScript 1.7.1
(function() {
  this.Application.State('Game', {
    getTile: function(tile) {
      if (tile) {
        return TILE_ASSOC[tile.index];
      } else {
        return -1;
      }
    },
    processTile: function(map, x, y) {
      var flat, flatLen, height, res, thisTile, tile, width;
      x *= 2;
      y *= 2;
      width = MAP[0].length - 1;
      height = MAP.length - 1;
      thisTile = this.getTile(map.getTile(x, y));
      tile = {
        topLeft: this.getTile(map.getTile(x - 2, y - 2)),
        top: this.getTile(map.getTile(x, y - 2)),
        topRight: this.getTile(map.getTile(x + 2, y - 2)),
        left: this.getTile(map.getTile(x - 2, y)),
        right: this.getTile(map.getTile(x + 2, y)),
        bottomLeft: this.getTile(map.getTile(x - 2, y + 2)),
        bottom: this.getTile(map.getTile(x, y + 2)),
        bottomRight: this.getTile(map.getTile(x + 2, y + 2))
      };

      /*
      topLeft: if x and y then MAP[y-1][x-1] else null
      top: if y then MAP[y-1][x] else null
      topRight: if y and x<width then MAP[y-1][x+1] else null
      left: if x then MAP[y][x-1] else null
      right: if x<width then MAP[y][x+1] else null
      bottomLeft: if x and y<height then MAP[y+1][x-1] else null
      bottom: if y<height then MAP[y+1][x] else null
      bottomRight: if y<height and x<width then MAP[y+1][x+1] else null
       */
      res = [0, 0, 0, 0];
      switch (thisTile) {
        case TILE_TYPE.GROUND:
          flat = [7, 8, 9, 10, 13, 14, 15, 16, 19, 20, 21, 22, 25, 26, 27, 28];
          flatLen = flat.length - 1;
          res[0] = MAP_TILE[TILE_TYPE.GROUND][flat[rand(flatLen)]];
          res[2] = MAP_TILE[TILE_TYPE.GROUND][flat[rand(flatLen)]];
          res[1] = MAP_TILE[TILE_TYPE.GROUND][flat[rand(flatLen)]];
          res[3] = MAP_TILE[TILE_TYPE.GROUND][flat[rand(flatLen)]];
          if (tile.right !== thisTile && tile.right !== TILE_TYPE.WATER) {
            res[1] = MAP_TILE[TILE_TYPE.GROUND][11];
            res[3] = MAP_TILE[TILE_TYPE.GROUND][17];
          }
          if (tile.left !== thisTile && tile.left !== TILE_TYPE.WATER) {
            res[0] = MAP_TILE[TILE_TYPE.GROUND][6];
            res[2] = MAP_TILE[TILE_TYPE.GROUND][12];
          }
          if (tile.top !== thisTile && tile.top !== TILE_TYPE.WATER) {
            res[0] = MAP_TILE[TILE_TYPE.GROUND][1];
            res[1] = MAP_TILE[TILE_TYPE.GROUND][2];
          }
          if (tile.bottom !== thisTile && tile.bottom !== TILE_TYPE.WATER) {
            res[2] = MAP_TILE[TILE_TYPE.GROUND][31];
            res[3] = MAP_TILE[TILE_TYPE.GROUND][32];
          }
          if (tile.left !== thisTile && tile.top !== thisTile && tile.left !== TILE_TYPE.WATER && tile.top !== TILE_TYPE.WATER) {
            res[0] = MAP_TILE[TILE_TYPE.GROUND][0];
          }
          if (tile.right !== thisTile && tile.top !== thisTile && tile.right !== TILE_TYPE.WATER && tile.top !== TILE_TYPE.WATER) {
            res[1] = MAP_TILE[TILE_TYPE.GROUND][5];
          }
          if (tile.left !== thisTile && tile.bottom !== thisTile && tile.left !== TILE_TYPE.WATER && tile.bottom !== TILE_TYPE.WATER) {
            res[2] = MAP_TILE[TILE_TYPE.GROUND][30];
          }
          if (tile.right !== thisTile && tile.bottom !== thisTile && tile.right !== TILE_TYPE.WATER && tile.bottom !== TILE_TYPE.WATER) {
            res[3] = MAP_TILE[TILE_TYPE.GROUND][35];
          }
          break;
        case TILE_TYPE.WAll:
          flat = [7, 8, 9, 10, 13, 14, 15, 16, 19, 20, 21, 22, 25, 26, 27, 28];
          flatLen = flat.length - 1;
          res[0] = MAP_TILE[TILE_TYPE.WAll][flat[rand(flatLen)]];
          res[2] = MAP_TILE[TILE_TYPE.WAll][flat[rand(flatLen)]];
          res[1] = MAP_TILE[TILE_TYPE.WAll][flat[rand(flatLen)]];
          res[3] = MAP_TILE[TILE_TYPE.WAll][flat[rand(flatLen)]];
          if (tile.right !== thisTile) {
            res[1] = MAP_TILE[TILE_TYPE.WAll][11];
            res[3] = MAP_TILE[TILE_TYPE.WAll][17];
          }
          if (tile.left !== thisTile) {
            res[0] = MAP_TILE[TILE_TYPE.WAll][6];
            res[2] = MAP_TILE[TILE_TYPE.WAll][12];
          }
          if (tile.top !== thisTile) {
            res[0] = MAP_TILE[TILE_TYPE.WAll][1];
            res[1] = MAP_TILE[TILE_TYPE.WAll][2];
          }
          if (tile.bottom !== thisTile) {
            res[2] = MAP_TILE[TILE_TYPE.WAll][31];
            res[3] = MAP_TILE[TILE_TYPE.WAll][32];
          }
          if (tile.left !== thisTile && tile.top !== thisTile) {
            res[0] = MAP_TILE[TILE_TYPE.WAll][0];
          }
          if (tile.right !== thisTile && tile.top !== thisTile) {
            res[1] = MAP_TILE[TILE_TYPE.WAll][5];
          }
          if (tile.left !== thisTile && tile.bottom !== thisTile) {
            res[2] = MAP_TILE[TILE_TYPE.WAll][30];
          }
          if (tile.right !== thisTile && tile.bottom !== thisTile) {
            res[3] = MAP_TILE[TILE_TYPE.WAll][35];
          }
          break;
        case TILE_TYPE.WATER:
          res[0] = MAP_TILE[TILE_TYPE.WATER][45];
          res[1] = MAP_TILE[TILE_TYPE.WATER][46];
          res[2] = MAP_TILE[TILE_TYPE.WATER][57];
          res[3] = MAP_TILE[TILE_TYPE.WATER][58];
          if (tile.right !== thisTile) {
            res[1] = MAP_TILE[TILE_TYPE.WATER][47];
            res[3] = MAP_TILE[TILE_TYPE.WATER][59];
          }
          if (tile.left !== thisTile) {
            res[0] = MAP_TILE[TILE_TYPE.WATER][44];
            res[2] = MAP_TILE[TILE_TYPE.WATER][56];
          }
          if (tile.top !== thisTile) {
            res[0] = MAP_TILE[TILE_TYPE.WATER][33];
            res[1] = MAP_TILE[TILE_TYPE.WATER][34];
          }
          if (tile.bottom !== thisTile) {
            res[2] = MAP_TILE[TILE_TYPE.WATER][65];
            res[3] = MAP_TILE[TILE_TYPE.WATER][66];
          }
          if (tile.left !== thisTile && tile.top !== thisTile) {
            res[0] = MAP_TILE[TILE_TYPE.WATER][32];
          }
          if (tile.right !== thisTile && tile.top !== thisTile) {
            res[1] = MAP_TILE[TILE_TYPE.WATER][35];
          }
          if (tile.left !== thisTile && tile.bottom !== thisTile) {
            res[2] = MAP_TILE[TILE_TYPE.WATER][64];
          }
          if (tile.right !== thisTile && tile.bottom !== thisTile) {
            res[3] = MAP_TILE[TILE_TYPE.WATER][67];
          }
          break;
        case TILE_TYPE.ICE:
          flat = [7, 8, 9, 10, 13, 14, 15, 16, 19, 20, 21, 22, 25, 26, 27, 28];
          flatLen = flat.length - 1;
          res[0] = MAP_TILE[TILE_TYPE.ICE][flat[rand(flatLen)]];
          res[2] = MAP_TILE[TILE_TYPE.ICE][flat[rand(flatLen)]];
          res[1] = MAP_TILE[TILE_TYPE.ICE][flat[rand(flatLen)]];
          res[3] = MAP_TILE[TILE_TYPE.ICE][flat[rand(flatLen)]];
          if (tile.right !== thisTile) {
            res[1] = MAP_TILE[TILE_TYPE.ICE][11];
            res[3] = MAP_TILE[TILE_TYPE.ICE][17];
          }
          if (tile.left !== thisTile) {
            res[0] = MAP_TILE[TILE_TYPE.ICE][6];
            res[2] = MAP_TILE[TILE_TYPE.ICE][12];
          }
          if (tile.top !== thisTile) {
            res[0] = MAP_TILE[TILE_TYPE.ICE][1];
            res[1] = MAP_TILE[TILE_TYPE.ICE][2];
          }
          if (tile.bottom !== thisTile) {
            res[2] = MAP_TILE[TILE_TYPE.ICE][31];
            res[3] = MAP_TILE[TILE_TYPE.ICE][32];
          }
          if (tile.left !== thisTile && tile.top !== thisTile) {
            res[0] = MAP_TILE[TILE_TYPE.ICE][0];
          }
          if (tile.right !== thisTile && tile.top !== thisTile) {
            res[1] = MAP_TILE[TILE_TYPE.ICE][5];
          }
          if (tile.left !== thisTile && tile.bottom !== thisTile) {
            res[2] = MAP_TILE[TILE_TYPE.ICE][30];
          }
          if (tile.right !== thisTile && tile.bottom !== thisTile) {
            res[3] = MAP_TILE[TILE_TYPE.ICE][35];
          }
          break;
        case TILE_TYPE.ARMOR:
          res = MAP_TILE[TILE_TYPE.ARMOR];
      }
      map.getTile(x, y).index = res[0];
      map.getTile(x + 1, y).index = res[1];
      map.getTile(x, y + 1).index = res[2];
      return map.getTile(x + 1, y + 1).index = res[3];
    },
    create: function() {
      var index, line, map, mapHeight, mapWidth, name, rx, ry, value, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3;
      map = this.game.add.tilemap(null, 16, 16);
      map.addTilesetImage('map');
      this.layer = map.create(name, MAP[0].length * 2, MAP.length * 2, 16, 16);
      mapWidth = map.width - 1;
      mapHeight = map.height - 1;
      for (y = _i = 0, _len = MAP.length; _i < _len; y = ++_i) {
        line = MAP[y];
        for (x = _j = 0, _len1 = line.length; _j < _len1; x = ++_j) {
          value = line[x];
          rx = x * 2;
          ry = y * 2;
          map.putTile(MAP_TILE[value][0], rx, ry, this.layer);
          map.putTile(MAP_TILE[value][0], rx + 1, ry, this.layer);
          map.putTile(MAP_TILE[value][0], rx, ry + 1, this.layer);
          map.putTile(MAP_TILE[value][0], rx + 1, ry + 1, this.layer);
        }
      }
      for (y = _k = 0, _len2 = MAP.length; _k < _len2; y = ++_k) {
        line = MAP[y];
        for (x = _l = 0, _len3 = line.length; _l < _len3; x = ++_l) {
          value = line[x];
          this.processTile(map, x, y);
        }
      }
      map.setCollision([].concat(MAP_TILE[TILE_TYPE.WAll], MAP_TILE[TILE_TYPE.ARMOR], MAP_TILE[TILE_TYPE.WATER]), true, this.layer);

      /*
        tile = @getTile(value,
            topLeft: if x and y then MAP[y-1][x-1] else null
            top: if y then MAP[y-1][x] else null
            topRight: if x and y then MAP[y-1][x-1] else null
      
            )
          rx = x * 2
          ry = y * 2
          map.putTile(tile[0], rx, ry, layers[TILE_TYPE[value]]);
          map.putTile(tile[1], rx+1, ry, layers[TILE_TYPE[value]]);
          map.putTile(tile[2], rx, ry+1, layers[TILE_TYPE[value]]);
          map.putTile(tile[3], rx+1, ry+1, layers[TILE_TYPE[value]]);
       */
      this.game.world.setBounds(0, 0, GAME.WIDTH, GAME.HEIGHT);
      this.bullets = [];
      this.game.groups = [];
      for (name in GROUP) {
        index = GROUP[name];
        this.game.groups[index] = this.game.add.group();
        this.game.groups[index].enableBody = true;
        this.game.groups[index].enableBodyDebug = true;
      }
      this.player = new Tank(this.game, 32 * 9, 32 * 15, GROUP.ENEMY_BULLET);
      return this.playerController = new Application.Controller.User(this.game, this.player);
    },
    update: function() {
      this.playerController.update();
      this.game.physics.arcade.collide(this.player.body, this.layer);
      return this.game.physics.arcade.collide(this.player.bullets, this.layer, this.player.onBulletCollide);
    }
  });

}).call(this);

//# sourceMappingURL=game.map
